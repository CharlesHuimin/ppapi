#summary Important concepts for working with PPAPI.

= Interfaces =

The basic concept of PPAPI is the _interface._ In C, this is just a collection of function pointers associated with some similar concept. Interfaces are identified by a name, and should remain stable over time. If additions are necessary in the future, they can be added by creating a "Interface2" with the additions.

This scheme allows the browser and the plugin to implement different capabilities and versions of interfaces over time. For example, a plugin may want clipboard functionality provided on a `Clipboard` interface. If the browser supports working with the clipboard, it will return a pointer to the associated function pointers when queried with the interface name. If it doesn't support such operations, it will return NULL and the plugin will have to degrade. Likewise, a plugin may prefer a newer function on a `Clipboard2` interface. When run under an older browser, only `Clipboard` might be available and the plugin will have to make do.

Both the plugin and the browser expose a `void* GetInterface(const char* name)` function for the other to call to access functionality.

= Loading and identifying a plugin =

A plugin is identified my a `PP_Module`. This corresponds to one time a plugin library is loaded into a browser. There might be multiple plugins of different types loaded at the same time.

A `PP_Instance` identifies one instance of a plugin, which is one time the page specifies `&lt;embed&gt;`. There may be several instances of a plugin on a page. In this case, there will be one "module" and several "instances" within that module. If a plugin is used across several pages, it is up to the browser whether it loads one global module with many instances, or separate modules for each page. In Google Chrome, for example, there will be one separate module for each renderer process, which may in turn correspond to one tab, or multiple tabs, depending on the [http://www.chromium.org/developers/design-documents/process-models process model] and how the tabs were opened.

= PP_Var =

A `PP_Var` represents an object for binding to !JavaScript or the DOM. It can represent boolean types, numeric values, strings, and generic !JavaScript-type objects. It can be most convenient to think of a `PP_Var` as a !JavaScript variable, which doesn't have a predefined type associated with it.

=== PP_Var lifetimes ===

A `PP_Var` containing a string or an object is reference counted, with the object itself residing inside the browser. When the reference count reaches 0, the string or object will be freed. The plugin uses the functions `PPB_Var.AddRef` and `PPB_Var.Release` to take and release references.

It is legal to call `AddRef` and `Release` on any type of var. But since boolean and numeric types are "inline" inside the var, there is no extra memory management required.

*Important:* !JavaScript objects can have references to other !JavaScript objects. Keeping a reference to one object can in turn keep many other objects alive. For example, a plugin might have a reference to a simple callback object. But that object may have a reference to an object in the DOM. Keeping the reference to the callback object alive can in turn cause a leak of the entire DOM of the page.

In the C++ API, the `pp:Var` object acts like a smart pointer. The reference count will be automatically maintained for you, and the object or string will be alive as long as there is a `pp::Var` referencing it.

=== Numbers in PP_Var ===

!JavaScript does not distinguish between floating point numbers an integers. In practice, !JavaScript libraries implement types as an optimization, but particular behavior is not guaranteed, and the type (double vs. int) may depend on the sequence of operations used to compute the value.

As a result, a plugin should not assume that a particular numeric value is an integer or a double, but should be prepared to handle results in either type and convert as necessary.

=== Strings in PP_Var ===

A string is a sequence of UTF-8 characters. It is reference counted as described above. A plugin can create a new string using `PPB_Var.VarFromUtf8` and get the string associated with a var using `PPB_Var.VartoUtf8`.

=== Objects in PP_Var ===

Objects in variants are references to !JavaScript-accessible objects. You can use the `PPB_Var` interface to call functions and manipulate properties on the object.

= PP_Resource =

While a `PP_Var' represents a !JavaScript object or value, a resource represents an object managed exclusively within the plugin layer. Examples include audio devices, images, and drawing contexts. The resource value is an opaque handle assigned by the browser that identifies the object.

A resource is reference counted much like a `PP_Var'. The browser will keep the object alive so long as the reference count is nonzero. When the reference count reaches zero, it will be deleted.

=== Typical PP_Resource usage ===

Typically, a resource of one type is managed using one interface. A typical example of a resource interface is `ImageData`. It provides:

  * A `Create` function to create an image resource. The returned resources automatically has a reference count of 1. The plugin is responsible for eventually calling `PPB_Core.ReleaseResource` to release this reference. On error, the creation function will return a resource with a 0 `id`, which is an invalid resource handle.

  * An `IsImageData` function to querying the type of a resource. The browser internally maintains a type for each resource, although the `PP_Resource` struct does not carry an inherent type. In normal usage, a plugin will know the type of its resources since it will have created them, but in some cases, such as for debugging purposes, a plugin will want to check the type.

  * Then the interface will contain functions specifically for working with resources of that type. These functions will generally fail if provided a `PP_Resource` identifying a non-`ImageData` object.