#summary 2D painting model overview

= Introduction =

Most window systems and previous browser plugin rendering models use an invalidation model where the browser or window system notifies the plugin or application when a region has been exposed. PPAPI uses a retained mode where the browser always maintains an internal backing store for the plugin representing the last painted image.

This mode is important because PPAPI plugins are expected to be run in separate processes from the browser. Retained mode allows the browser to paint parts of the page without requiring locking or cross-process communication, while the plugin is simultaneously generating a new image in the background.

There is no way to access the internal backing store except through the 2D device API. The browser may use the backing store to paint at any time. If the plugin could write directly to the backing store, the browser might paint partial updates which would cause visual artifacts.

= Basic usage overview =

  # Create a {{{DeviceContext2D}}} and bind it to your plugin instance.
  # Create an {{{ImageData}}} to hold painted bits.
  # Call {{{PaintImageData}}} or {{{ReplaceContents}}} to copy your bits to the backing store.
  # Call {{{Flush}}} to flush the updates to the screen.
  # Wait for the flush callback before painting a new frame.

= Device context details =

See also:

  * C API header files for [http://code.google.com/p/ppapi/source/browse/trunk/c/ppb_device_context_2d.h DeviceContext2D] and [http://code.google.com/p/ppapi/source/browse/trunk/c/ppb_image_data.h ImageData]
  * C++ API header files for [http://code.google.com/p/ppapi/source/browse/trunk/cpp/device_context_2d.h DeviceContext2D] and [http://code.google.com/p/ppapi/source/browse/trunk/cpp/image_data.h ImageData]
  * Simple animation plugin TODO(brettw) write this!

=== Flushing ===

None of the update operations take effect until {{{Flush}}} is called. This allows the plugin to update discontinuous parts of the image in one "frame" without getting tearing or partial painting artifacts. It also allows a scroll and a paint of the exposed region to be done atomically.

A flush is complete when the bits have actually been copied to the screen. This means that the backing store of the device has been updated, and also that it has been composited with the page and displayed to the user. This allows the plugin to rate limit the number of updates it provides to the rate that can be copied to the screen. Since the plugin can generate paint messages asynchronously with the browser, if this didn't happen, the plugin could get significantly ahead of the browser in generating paints.

<blockquote>_Advanced note:_ A complete flush doesn't literally mean that the bits are on the screen, only that they're "on the way." A browser like Chrome can use this to overlap generating of the next frame with the update of the screen, while also preventing the plugin from getting more than one frame behind.</blockquote>

The application can run is synchronous or asynchronous flush mode. Asynchronous flush mode will notify the application that the flush has completed via a callback. Synchronous flush mode will block the caller until the Flush has been completed. Synchronous flush mode can only be used when running on a background thread. If a plugin's main thread could block on a flush call, it could not respond to input events which could cause a deadlock.

=== Optimized updating of the entire frame ===

Some types of plugins may update the entire plugin area for every frame (for example, a video player). In this case, using {{{PaintImageData}}} requires an extra copy to copy the data from the {{{ImageData}}} to the backing store of the device.

You can avoid this extra copy by replacing the contents of the backing store with a new {{{ImageData}}} object that you supply. After calling {{{ReplaceContents}}} the image you supply will be used as the new backing store for the device. The limitations of this approach are that your image must be sized exactly the same as the device's existing backing store, and that the plugin will no longer have access to the bitmap once it is owned by the device. Once the backing store has been replaced, you can use any device function to manipulate the contents including calling {{{ReplaceContents}}} again, or updating only portions of the device using {{{PaintImageData}}}.

If you are using {{{ReplaceContents}}}, you allocate a new {{{ImageData}}} each time you want to paint. The intent is that when you do a replace, the browser can cache the old backing store image and supply it back to you if you request an image of the same size. If you set {{{init_to_zero}}} to false when allocating the image, the browser doesn't even need to clear the old image. Painting in this mode is as efficient as a swap operation while giving the browser a little extra flexibility to allocate a new image if the sizes don't match, or to throw away the cached image if memory is low. Since the browser may choose to reallocate the image, you can not count on receiving the old contents of the device in the next image data allocation.

= Managing invalid rects =

Many applications are convenient to write using the "invalid region" mode where the application generates invalid rectangles and expects the system to call it back with all invalid regions when the application returns to the message loop.

To support this type of applications, the C++ wrapper provides a {{{PaintAggregator}}} convenience object that collects dirty rectangles and scroll requests and supplies an aggregated set of scrolls and paints to actually update the screen. Typical usage is as follows:

   # Keep a {{{pp::PaintAggregator}}} object associated with your plugin instance.
   # When your application runs, call {{{InvalidateRect}}} and {{{ScrollRect}}} on the aggregator as needed.
   # When you are ready to paint call {{{GetPendingUpdate}}} to get the list of scroll and paint requests to actually execute. These instructions are similar to a "Paint" request from a typical operating system.