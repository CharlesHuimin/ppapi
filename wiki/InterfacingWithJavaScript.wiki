#summary How to interface back and forth between a plugin and `JavaScript`.


= Implementing !JavaScript-accessible objects =

It is possible to provide a backend implementation of a {{{PP_Var}}} in native code that can be called from !JavaScript (or potentially other plugins). Calls to functions or to set and get properties will call through to functions you implement on your plugin's main thread.

In the C API, you provide an implementation of the interface {{{PPP_Class}}} and pass a pointer to your class to the {{{PPB_Var.CreateObject}}} function to actually create the object. In the C++ API, just inherit from {{{pp::ScriptableObject}}} and implement the virtual functions of that class. To convert your scriptable object to a var, just call the {{{pp::Var}}} constructor with a pointer to your object:

{{{
class MyObject : public pp::ScriptableObject {
  ...
};

pp::Var MakeMyObject() {
  return pp::Var(new MyObject());
}
}}}

You can now use your custom {{{pp::Var}}} just like any other in the system. You can call functions on it, get and set properties, and return it as the result of other functions for use by !JavaScript and other plugins. The lifetime of your object will be bound to the lifetime of the var, which is reference counted by the browser. When there are no more references to the object, the object's destructor will automatically be called; you don't need to do anything special to manage the lifetime of your object.

=== Properties ===

As discussed above, properties can be either strings or integers. Most plugins probably won't support arrays and will only implement string properties. However, you should be careful to check the type of the property name when responding to get/set/has property since it can be an integer.

If you have a property, be sure to not only implement the getter and setter, but also respond go {{{HasProperty}}} accordingly, and include your property name in response to {{{GetAllProperties}}}. Forgetting to do this can lead to unexpected behavior.

=== Error handling ===

Each function on the {{{PPP_Class}}}/{{{pp::ScriptableObject}}} has an out parameter corresponding to the exception. If you set this value to a non-void var, it will correspond to throwing an exception in !JavaScript (or, for PPAPI plugins, being passed up to the caller as the exception through the var interface). If you don't encounter an error, just don't write to the exception pointer.

When calling an object, you can specify a null exception (see above). However, when implementing an object, this exception will never be null. The browser will always create an exception object, and just won't pass it "up" the stack if the caller isn't interested. This frees the implementation from having to null-check the exception object.

Likewise, when manipulating an object, you can expect that the function won't do anything if the exception is non-void (see above). From the object implementation side, you don't need to worry about this behavior. Before calling into your implemention, the browser will check the exception passed in by the caller and will immediately return if the exception is non-void; you won't even see the call from the implementation side. This frees the implementation from having to check the exception for "type void".

When throwing an exception, your return value will be ignored. It is recommended that you return a void var (this is what you get using the default {{{pp::Var()}}} constructor).

This example shows how to do error handling to implement a function call to implement {{{object.doSomethingAwesome(3.14159);}}}.

{{{
pp::Var MyObject::Call(const pp::Var& method_name,
                       const std::vector<pp::Var>& args,
                       pp::Var* exception) {
  if (method_name.is_string() && method_name == "doSomethingAwesome") {
    if (args.size() != 1 || !args[0].is_number()) {
      // Error, we expect a number as the argument.
      *exception = pp::Var("Error calling doSomethingAwesome, you must pass exactly one number");
      return pp::Var();
    }
    return DoSomethingAwesome(args[0].AsDouble());
  }

  // Unknown method.
  *exception = pp::Var("Unknown function");
  return pp::Var();
}
}}}

=== The plugin "instance object" ===

If you want to allow !JavaScript on the page to call into your plugin, you expose an object that represents the plugin instance. In the C API, this is returned by the {{{PPP_Instance.GetInstanceObject}}} function implemented by the plugin. In the C++ API, just implement the virtual function {{{pp::Instance::GetInstanceObject}}}.

=== See also ===

  * The header file for the C interface [http://code.google.com/p/ppapi/source/browse/trunk/c/ppp_class.h PPP_Class].
  * The header file for the C++ wrapper [http://code.google.com/p/ppapi/source/browse/trunk/cpp/scriptable_object.h ScriptableObject].