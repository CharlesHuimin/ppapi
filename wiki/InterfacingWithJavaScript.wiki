#summary How to interface back and forth between a plugin and `JavaScript`.

= Overview =

A {{{PP_Var}}} (in the C API) or a {{{pp::Var}}} (in the C++ API) represents an object for binding to !JavaScript or the DOM. It can represent boolean types, numeric values, strings, and generic !JavaScript-type objects. It can be most convenient to think of a var as a !JavaScript variable, which doesn't have a predefined type associated with it.

=== Var lifetimes ===

A var containing a string or an object is reference counted, with the object itself residing inside the browser. When the reference count reaches 0, the string or object will be freed. A C plugin uses the functions `PPB_Var.AddRef` and `PPB_Var.Release` to take and release references.

It is legal to call `AddRef` and `Release` on any type of var. But since boolean and numeric types are "inline" inside the var, there is no extra memory management required.

*Important:* !JavaScript objects can have references to other !JavaScript objects. Keeping a reference to one object can in turn keep many other objects alive. For example, a plugin might have a reference to a simple callback object. But that object may have a reference to an object in the DOM. Keeping the reference to the callback object alive can in turn cause a leak of the entire DOM of the page.

In the C++ API, the {{{pp:Var}}} object acts like a smart pointer. The reference count will be automatically maintained for you, and the object or string will be alive as long as there is a {{{pp::Var}}} referencing it. Copying a {{{pp::Var}}} will create another reference to the same underlying object.

=== Numbers in PP_Var ===

!JavaScript does not distinguish between floating point numbers an integers. In practice, !JavaScript libraries implement types as an optimization, but particular behavior is not guaranteed, and the type (double vs. int) may depend on the sequence of operations used to compute the value.

As a result, a plugin should not assume that a particular numeric value is an integer or a double, but should be prepared to handle results in either type and convert as necessary.

=== Strings in PP_Var ===

A string is a sequence of UTF-8 characters. It is reference counted as described above. A plugin can create a new string using `PPB_Var.VarFromUtf8` and get the string associated with a var using `PPB_Var.VartoUtf8`.

=== Objects in PP_Var ===

Objects in variants are references to !JavaScript-accessible objects. You can use the `PPB_Var` interface to call functions and manipulate properties on the object.

= Accessing a Var =



= Implementing !JavaScript-accessible objects =

It is possible to provide a backend implementation of a {{{PP_Var}}} in native code that can be called from !JavaScript (or potentially other plugins). Calls to functions or to set and get properties will call through to functions you implement on your plugin's main thread.

In the C API, you provide an implementation of the interface {{{PPP_Class}}} and pass a pointer to your class to the {{{PPB_Var.CreateObject}}} function to actually create the object. In the C++ API, just inherit from {{{pp::ScriptableObject}}} and implement the virtual functions of that class. To convert your scriptable object to a var, just call the {{{pp::Var}}} constructor with a pointer to your object:

{{{
class MyObject : public pp::ScriptableObject {
  ...
};

pp::Var MakeMyObject() {
  return pp::Var(new MyObject());
}
}}}

You can now use your custom {{{pp::Var}}} just like any other in the system. You can call functions on it, get and set properties, and return it as the result of other functions for use by !JavaScript and other plugins. The lifetime of your object will be bound to the lifetime of the var, which is reference counted by the browser. When there are no more references to the object, the object's destructor will automatically be called; you don't need to do anything special to manage the lifetime of your object.

=== Properties ===

As discussed above, properties can be either strings or integers. Most plugins probably won't support arrays and will only implement string properties. However, you should be careful to check the type of the property name when responding to get/set/has property since it can be an integer.

If you have a property, be sure to not only implement the getter and setter, but also respond go {{{HasProperty}}} accordingly, and include your property name in response to {{{GetAllProperties}}}. Forgetting to do this can lead to unexpected behavior.

=== Error handling ===

Each function on the {{{PPP_Class}}}/{{{pp::ScriptableObject}}} has an out parameter corresponding to the exception. If you set this value to a non-void var, it will correspond to throwing an exception in !JavaScript (or, for PPAPI plugins, being passed up to the caller as the exception through the var interface). If you don't encounter an error, just don't write to the exception pointer.

When calling an object, you can specify a null exception (see above). However, when implementing an object, this exception will never be null. The browser will always create an exception object, and just won't pass it "up" the stack if the caller isn't interested. This frees the implementation from having to null-check the exception object.

Likewise, when manipulating an object, you can expect that the function won't do anything if the exception is non-void (see above). From the object implementation side, you don't need to worry about this behavior. Before calling into your implemention, the browser will check the exception passed in by the caller and will immediately return if the exception is non-void; you won't even see the call from the implementation side. This frees the implementation from having to check the exception for "type void".

When throwing an exception, your return value will be ignored. It is recommended that you return a void var (this is what you get using the default {{{pp::Var()}}} constructor).

This example shows how to do error handling to implement a function call to implement {{{object.doSomethingAwesome(3.14159);}}}.

{{{
pp::Var MyObject::Call(const pp::Var& method_name,
                       const std::vector<pp::Var>& args,
                       pp::Var* exception) {
  if (method_name.is_string() && method_name == "doSomethingAwesome") {
    if (args.size() != 1 || !args[0].is_number()) {
      // Error, we expect a number as the argument.
      *exception = pp::Var("Error calling doSomethingAwesome, you must pass exactly one number");
      return pp::Var();
    }
    return DoSomethingAwesome(args[0].AsDouble());
  }

  // Unknown method.
  *exception = pp::Var("Unknown function");
  return pp::Var();
}
}}}

=== The plugin "instance object" ===

If you want to allow !JavaScript on the page to call into your plugin, you expose an object that represents the plugin instance. In the C API, this is returned by the {{{PPP_Instance.GetInstanceObject}}} function implemented by the plugin. In the C++ API, just implement the virtual function {{{pp::Instance::GetInstanceObject}}}.

=== See also ===

  * The header file for the C interface [http://code.google.com/p/ppapi/source/browse/trunk/c/ppp_class.h PPP_Class].
  * The header file for the C++ wrapper [http://code.google.com/p/ppapi/source/browse/trunk/cpp/scriptable_object.h ScriptableObject].